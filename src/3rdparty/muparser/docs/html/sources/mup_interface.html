
<!-- 
//
//
//  
//   The parser interface
//
//
//
-->

<br/>
<h1><a id="idInterface"></a>The parser interface</h1>
The following section gives an overview of the public parser member functions as well as of the functions 
exported by the DLL version of the parser.


<h2><a id="idInit"></a>Parser initialization / deinitialization</h2>
<h4>[DLL interface]</h4>
Create a new instance handle. You can create as many different instance handles as you like. Each will 
internally reference a different parser object. When using the DLL it is necessary to manually release 
any parser handle created by <code>mupInit()</code> by calling <code>mupRelease(hParser)</code>.

<pre>
<span class="code_kw_lib">muParserHandle_t</span> hParser;
hParser = <span class="code_kw_lib">mupInit</span>(); <span class="code_cmt">// Create a new handle</span>

<span class="code_cmt">// use the parser...</span>

<span class="code_kw_lib">mupRelease</span>(hParser); <span class="code_cmt">// Release an existing parser handle</span>
</pre>

Internally a handle is nothing more than a pointer to a parser object casted to a void pointer.


<h4>[Parser class interface]</h4>
Code for creating a new parser object. (In case of dynamic allocation use <code>new</code> and <code>delete</code> 
for initialization and deinitialization.) 

<pre>
<span class="code_kw_lib">mu::Parser</span> parser;
</pre>

<!-- 
//
//   The parser interface / Setting the expression
//
-->

<h2><a id="idSetExpr"></a>Setting the expression</h2>
<h4>[DLL interface]</h4>
Setting the expression when using the DLL requires a valid parser handle and a pointer to 
<code>const char</code> pointing to the expression.

<pre>
<span class="code_kw_lib">mupSetExpr</span>(hParser, szLine);
</pre>
<small>See also: <i>example2/example2.c</i>.</small>

<h4>[Parser class interface]</h4>
Setting the expression using the parser class requires a <code>std::string</code> containing the expression as the
only parameter.
<pre>
<span class="code_kw_lib">parser.SetExpr</span>(line);
</pre>
<small>See also: <i>example1/example1.cpp; src/muParserTest.cpp</i>.</small>

<!-- 
//
//   The parser interface / Evaluating the expression
//
-->

<h2><a id="idEval"></a>Evaluating an expression</h2>
<h3><a id="idEvalSimple"></a>Single return value</h3>
<p>
Expression evaluation is done by calling the <code>mupEval()</code> function in the DLL version or the 
<code>Eval()</code> member function of a parser object. When evaluating an expression for the first time
the parser evaluates the expression string directly and creates a bytecode during this first time evaluation. 
Every sucessive call to <code>Eval()</code> will evaluate the bytecode directly unless you call a function 
that will silently reset the parser to string parse mode. Some functions invalidate the bytecode due to 
possible changes in callback function pointers or variable addresses. By doing so they effectively cause a 
recreation of the bytecode during the next call to <code>Eval()</code>. 
</p>

<p>
Internally there are different evaluation functions. One for parsing from a string, the other for
parsing from bytecode (and a third one used only if the expression can be simplified to a constant). 
Initially, <code>Eval()</code> will call the string parsing function which is slow due to all the 
necessary syntax checking, variable lookup, and bytecode creation. Once this
function succeeds, <code>Eval()</code> will change its internal parse function pointer to either
the bytecode parsing function or the const result function which are significantly (approx. 1000 times) 
faster. You don't have to worry about this, it's done automatically, just keep in mind that the 
first time evaluation of an expression is significantly slower than any successive call to 
<code>Eval()</code>.
</p>

<h4>[DLL interface]</h4>
<pre>
<span class="code_kw">double</span> fVal;
fVal = <span class="code_kw_lib">mupEval</span>(hParser);
</pre>
<small>See also: <i>example2/example2.c</i>.</small>

<h4>[Parser class interface]</h4>
<pre>
<span class="code_kw">double</span> fVal;
<span class="code_kw">try</span>
{
  fVal = <span class="code_kw_lib">parser.Eval()</span>;
}
<span class="code_kw">catch</span> (<span class="code_kw_lib">Parser::exception_type</span> &amp;e)
{
  std::cout &lt;&lt; e.GetMsg() &lt;&lt; endl;
}
</pre>
<small>See also: <i>example1/example1.cpp</i>.</small>

<p>
If the expression contains multiple separated subexpressions the return value of <code>Eval()</code>/
<code>mupEval()</code> is the result of the last subexpression. If you need all of the results 
use the Eval overload described in the next section.
</p>

<h3><a id="idEvalMulti"></a>Multiple return values</h3>
<p>
muParser accepts expressions that are made up of several subexpressions <a href="mup_locale.html#idLoc">delimited by the function 
argument separator</a>. For instance take a look at the following expression:
</p>

<pre>
sin(x),y+x,x*x
</pre>

<p>
It is made up of three expression separated by commas hence it will create three return values. 
(Assuming the comma is defined as the argument separator). The number of return values as well
as their value can be queried with an overload of the <code>Eval</code> function. This overload
takes a reference to an integer value for storing the total number of return values and returns
a pointer to an array of <code>value_type</code> holding the actual values with the first value 
at the botton of the array and the last at the top.
</p>
<h4>[DLL interface]</h4>
<pre>
  <span class="code_kw">int</span> nNum, i;
  <span class="code_kw_lib">muFloat_t</span> *v = mupEvalMulti(hParser, &nNum);
  <span class="code_kw">for</span> (i=<span class="code_digit">0</span>; i&lt;nNum; ++i)
  {
    <span class="code_kw">printf</span>(<span class="code_str">"v[i]=%2.2f\n"</span>, v[i]);
  }
</pre>

<h4>[Parser class interface]</h4>
<pre>
  <span class="code_kw">int nNum</span>;
  <span class="code_kw_lib">value_type</span> *v = <span class="code_kw_lib">parser.Eval</span>(nNum);
  <span class="code_kw">for</span> (<span class="code_kw">int</span> i=<span class="code_digit">0</span>; i&lt;nNum; ++i)
  {
    std::cout &lt;&lt; v[i] &lt;&lt; <span class="code_str">"\n"</span>;
  }
</pre>
<small>See also: <i>example1/example1.cpp</i>.</small>

<p>
The function <code>GetNumResults()</code> can be used in order to finf out whether a given expression has produced
multiple return values.
</p>

<h3><a id="idEvalBulk"></a>Bulk mode evaluations</h3>
<p>
The basic idea behind the bulkmode is to minimize the overhead of function calls and loops when using 
muParser inside of large loops. Each loop turn requires a distinct set of variables and setting these 
variables followed by calling the evaluation function can by slow if the loop is implemented in a managed
language. This overhead can be minimized by precalculating the variable values and calling just a single 
evaluation function. In reality the bulkmode doesn't make much of a difference when used in C++ but it 
brings a significant increase in performance when used in .NET applications. If muParser 
<a href="mup_usage.html#idCompilerSwitches_openMP">was compiled with OpenMP support</a> the 
calculation load will be spread among all available CPU cores. When using the bulk mode variable 
pointers submitted to the DefineVar function must be arrays instead of single variables. All
variable arrays must have the same size and each array index represents a distinct set of variables
to be used in the expression. 
</p>
<p>
Although the bulk mode does work with standard callback functions it may sometimes be necessary to have
additional informations inside a callback function. Especially Informations like the index of the current 
variable set and the index of the thread performing the calculation may be crucial to the
evaluation process. To facilitate this need a special set of callback functions was added.
</p>

<h4>[DLL interface]</h4>
<pre>
<span class="code_kw">void</span> CalcBulk()
{
  <span class="code_kw">int</span> nBulkSize = <span class="code_digit">200</span>, i;

  <span class="code_cmt">// allocate the arrays for variables and return values</span>
  <span class="code_kw_lib">muFloat_t</span> *x = (<span class="code_kw_lib">muFloat_t</span>*)malloc(nBulkSize * <span class="code_kw">sizeof</span>(<span class="code_kw_lib">muFloat_t</span>));
  <span class="code_kw_lib">muFloat_t</span> *y = (<span class="code_kw_lib">muFloat_t</span>*)malloc(nBulkSize * <span class="code_kw">sizeof</span>(<span class="code_kw_lib">muFloat_t</span>));
  <span class="code_kw_lib">muFloat_t</span> *r = (<span class="code_kw_lib">muFloat_t</span>*)malloc(nBulkSize * <span class="code_kw">sizeof</span>(<span class="code_kw_lib">muFloat_t</span>));

  <span class="code_cmt">// initialize the parser and variables</span>
  <span class="code_kw_lib">muParserHandle_t</span> hParser = <span class="code_kw_lib">mupCreate</span>(<span class="code_kw_lib">muBASETYPE_FLOAT</span>);  
  <span class="code_kw">for</span> (i=<span class="code_digit">0</span>; i&lt;nBulkSize; ++i)
  {
    x[i] = i;
    y[i] = i;
    r[i] = <span class="code_digit">0</span>;
  }

  <span class="code_cmt">// Set up variables and functions and evaluate the expression</span>
  <span class="code_kw_lib">mupDefineVar</span>(hParser, <span class="code_str">"x"</span>, x);  
  <span class="code_kw_lib">mupDefineVar</span>(hParser, <span class="code_str">"y"</span>, y);
  <span class="code_kw_lib">mupDefineBulkFun1</span>(hParser, <span class="code_str">"bulktest"</span>, BulkTest);
  <span class="code_kw_lib">mupSetExpr</span>(hParser, <span class="code_str">"bulktest(x+y)"</span>);
  <span class="code_kw_lib">mupEvalBulk</span>(hParser, r, nBulkSize);
  <span class="code_kw">if</span> (<span class="code_kw_lib">mupError</span>(hParser))
  {
    printf(<span class="code_str">"\nError:\n"</span>);
    printf(<span class="code_str">"------\n"</span>);
    printf(<span class="code_str">"Message:  %s\n"</span>, <span class="code_kw_lib">mupGetErrorMsg</span>(hParser) );
    printf(<span class="code_str">"Token:    %s\n"</span>, <span class="code_kw_lib">mupGetErrorToken</span>(hParser) );
    printf(<span class="code_str">"Position: %d\n"</span>, <span class="code_kw_lib">mupGetErrorPos</span>(hParser) );
    printf(<span class="code_str">"Errc:     %d\n"</span>, <span class="code_kw_lib">mupGetErrorCode</span>(hParser) );
    <span class="code_kw">return</span>;
  }

  <span class="code_cmt">// Output the result</span>
  <span class="code_kw">for</span> (i=0; i&lt;nBulkSize; ++i)
  {
    printf(<span class="code_str">"%d: bulkfun(%2.2f + %2.2f) = %2.2f\n"</span>, i, x[i], y[i], r[i]);
  }

  free(x);
  free(y);
  free(r);
}
</pre>

<!-- 
//
//   The parser interface / Defining identifier character sets
//
-->

<h2><a id="idDefCharset"></a>Defining identifier character sets</h2>
Sometimes it is necessary to change the character sets that are used for token identifiers in 
order to avoid conflicts. The parser uses three different character sets.
<ul>
  <li>The name character set, is used for:
  <ul>
    <li>function identifiers</li>
    <li>variable identifiers</li>
    <li>constant identifiers</li>
  </ul>
  </li>
  <li>The operator character set is used for:
  <ul>
    <li>binary operator identifiers</li>
    <li>postfix operator identifiers</li>
  </ul></li>

  <li>The Infix operator charset is used for infix operator identifiers only</li>
</ul>

When using the default implementation <code>mu::muParser</code> directly you can skip this
section. (The DLL version uses the default implementation internally.)

<h4>[DLL interface]</h4>
<pre>
<span class="code_kw_lib">mupDefineNameChars</span>(hParser, <span class="code_str">"0123456789_"
                            "abcdefghijklmnopqrstuvwxyz"
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>);
<span class="code_kw_lib">mupDefineOprtChars</span>(hParser, <span class="code_str">"abcdefghijklmnopqrstuvwxyz"
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                            "+-*^/?&lt;&gt;=#!$%&amp;|~'_"</span>);
<span class="code_kw_lib">mupDefineInfixOprtChars</span>(hParser, <span class="code_str">"/+-*^?&lt;&gt;=#!$%&amp;|~'_"</span>);
</pre>

<h4>[Parser class interface]</h4>
<pre>
<span class="code_kw_lib">parser.DefineNameChars</span>(<span class="code_str">"0123456789_"
                       "abcdefghijklmnopqrstuvwxyz"
                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>);
<span class="code_kw_lib">parser.DefineOprtChars</span>(<span class="code_str">"abcdefghijklmnopqrstuvwxyz"
                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                       "+-*^/?&lt;&gt;=#!$%&amp;|~'_"</span>);
<span class="code_kw_lib">parser.DefineInfixOprtChars</span>(<span class="code_str">"/+-*^?&lt;&gt;=#!$%&amp;|~'_"</span>);
</pre>
<small>See also: <i>ParserLib/muParser.cpp; ParserLib/muParserInt.cpp</i>.</small>

<!-- 
//
//   The parser interface / Defining parser variables
//
-->

<h2><a id="idDefVar"></a>Defining parser variables</h2>
Custom variables can be defined either explicit in the code by using the <code>DefineVar</code> function or implicit by the parser. Implicit declaration will call a variable factory function provided by the user. The parser is never the owner of its variables. So you must take care of their destruction in case of dynamic allocation. The general idea is to bind every parser variable to a C++ variable. For this reason, you have to make sure the C++ variable stays valid as long as you process a formula that needs it. Only variables of type <code>double</code> are supported.


<h2><a id="idDefVarEx"></a>Explicitely defining variables</h2>
Explicitely in this context means you have to do add the variables manually it in your application code. So you must know in advance which variables you intend to use. If this is not the case have a look at
the section on <a href="#idDefVarIm">Implicit creation of new variables</a>.

<table>
  <tr>
    <td><img src="images/warning.gif" alt="warning"/></td>  
    <td>Defining new Variables will reset the parser bytecode. Do not use this function just for changing the values of variables! It would dramatically reduce the parser performance! Once the parser knows the address of the variable there is no need to explicitely call a function for changing the value. Since the parser knows the address it knows the value too so simply change the C++ variable in your code directly!</td>
  </tr>
</table>

<h4>[DLL interface]</h4>
The first parameter is a valid parser handle, the second the variable name and the third a pointer to 
the associated C++ variable.

<pre>
<span class="code_kw">double</span> fVal=<span class="code_digit">0</span>;
<span class="code_kw_lib">mupDefineVar</span>(hParser, <span class="code_str">"a"</span>, &amp;fVal);  
</pre>
<small>See also: <i>example2/example2.c</i>.</small>

<h4>[Parser class interface]</h4>

The first parameter is the variable name and the second a pointer to the associated C++ variable.

<pre>
<span class="code_kw">double</span> fVal=0;
<span class="code_kw_lib">parser.DefineVar</span>(<span class="code_str">"a"</span>, &amp;fVal);
</pre>
<small>See also: <i>example1/example1.cpp; src/muParserTest.cpp</i>.</small>


<h2><a id="idDefVarIm"></a>Implicit creation of new variables</h2>
Implicit declaration of new variables is only possible by setting a factory function. Implicit creation 
means that everytime the parser finds an unknown token at a position where a variable could be located it 
creates a new variable with that name automatically. The necessary factory function must be of type:

<pre>
<span class="code_kw">double</span>* (*<span class="code_kw_lib">facfun_type</span>)(<span class="code_kw">const char</span>*, <span class="code_kw">void</span>*)
</pre> 

The first argument to a factory function is the name of the variable found by the parser. The second is a pointer
to user defined data. This pointer can be used to provide a pointer to a class that implements the actual factory. 
By doing this it is possible to use custom factory classes depending on the variable name.

<table>
<tr><td><img src="images/warning.gif" alt="warning"/></td> <td>Be aware of name conflicts! Please notice that recognizing the name of an undefined variable is the last step during parser token detection. If the potential variable name starts with identifiers that could be interpreted as a function or operator it will be detected as such most likely resulting in an syntax error.</td>
</tr>
</table>

The following code is an example of a factory function. The example does not use dynamic allocation for 
the new variables although this would be possible too. But when using dynamic allocation you must keep
track of the variables allocated implicitely in order to free them later on. 

<pre>
<span class="code_kw">double</span>* AddVariable(<span class="code_kw">const char</span> *a_szName, <span class="code_kw">void</span> *pUserData)
{
  <span class="code_kw">static double</span> afValBuf[<span class="code_digit">100</span>];  
  <span class="code_kw">static int</span> iVal = <span class="code_digit">0</span>;          

  std::cout &lt;&lt; <span class="code_str">"Generating new variable \""</span> 
            &lt;&lt; a_szName &lt;&lt; <span class="code_str">"\" (slots left: " </span>
            &lt;&lt; <span class="code_digit">99</span>-iVal &lt;&lt; <span class="code_str">")"</span> &lt;&lt; endl;
	
  <span class="code_cmt">// you could also do:</span>
  <span class="code_cmt">// MyFactory *pFactory = (MyFactory*)pUserData;</span>
  <span class="code_cmt">// pFactory->CreateNewVariable(a_szName);</span>
  
  afValBuf[iVal++] = <span class="code_digit">0</span>;
  <span class="code_kw">if</span> (iVal>=<span class="code_digit">99</span>)
    <span class="code_kw">throw</span> <span class="code_kw_lib">mu::Parser::exception_type</span>(<span class="code_str">"Variable buffer overflow."</span>);

  <span class="code_kw">return</span> &amp;afValBuf[iVal];
}
</pre>
<small>See also: <i>example1/example1.cpp</i>.</small>

In order to add a variable factory use the <code>SetVarFactory</code> functions. The first parameter 
is a pointer to the static factory function, the second parameter is optional and represents a pointer 
to user defined data. Without a variable factory each undefined variable will cause an undefined token error. Factory 
functions can be used to query the values of newly created variables directly from a
database. If you emit errors from a factory function be sure to throw an exception of
type <code>ParserBase::exception_type</code> all other exceptions will be caught internally
and result in an internal error.

<h4>[DLL interface]</h4>
<pre>
<span class="code_kw_lib">mupSetVarFactory</span>(hParser, AddVariable, pUserData);
</pre>
<small>See also: <i>example2/example2.c</i>.</small>

<h4>[Parser class interface]</h4>
<pre>
<span class="code_kw_lib">parser.SetVarFactory</span>(AddVariable, pUserData);
</pre>
<small>See also: <i>example1/example1.cpp</i>.</small>


<!-- 
//
//   The parser interface / Defining parser constants
//
-->


<h2><a id="idDefConst"></a>Defining parser constants</h2>
Parser constants can either be values of type <code>double</code> or <code>string</code>. Constness 
refers to the bytecode. Constants will be stored by their value in the bytecode, not by a reference to
their address. Thus accessing them is faster. They may be optimized away if this is possible. 
Defining new constants or changing old ones will reset the parser to string parsing mode thus resetting
the bytecode.
<br/>
The Names of user defined constants may contain only the following characters: <code>0-9, a-z, A-Z, _</code>, and they may not start with a number. Violating this rule will raise a parser error.

<h4>[DLL interface]</h4>
<pre>
<span class="code_cmt">// Define value constants _pi</span>
<span class="code_kw_lib">mupDefineConst</span>(hParser, <span class="code_str">"_pi"</span>, (<span class="code_kw">double</span>)PARSER_CONST_PI);  

<span class="code_cmt">// Define a string constant named strBuf</span>
<span class="code_kw_lib">mupDefineStrConst</span>(<span class="code_str">"strBuf"</span>, <span class="code_str">"hello world"</span>);
</pre>
<small>See also: <i>example2/example2.c</i>.</small>


<h4>[Parser class interface]</h4>
<pre>
<span class="code_cmt">// Define value constant _pi</span>
<span class="code_kw_lib">parser.DefineConst</span>(<span class="code_str">"_pi"</span>, (<span class="code_kw">double</span>)PARSER_CONST_PI);

<span class="code_cmt">// Define a string constant named strBuf</span>
<span class="code_kw_lib">parser.DefineStrConst</span>(<span class="code_str">"strBuf"</span>, <span class="code_str">"hello world"</span>);
</pre>
<small>See also: <i>example1/example1.cpp; src/muParserTest.cpp</i>.</small>

<!-- 
//
//   The parser interface / Querying parser variables
//
-->

<h2><a id="idQueryVar"></a>Querying parser variables</h2>
Keeping track of all variables can be a difficult task. For simplification the parser allows the user
to query the variables defined in the parser. There are two different sets of variables that can 
be accessed:

<ul>
  <li>Varaiables defined in the parser</li>
  <li>Variables used in the current expression</li>
</ul>

Since the usage of the necessary commands is similar the following example shows 
querying the parser variables only.


<h4>[DLL interface]</h4>
For querying the variables used in the expression exchange <code>mupGetVarNum(...)</code> with 
<code>mupGetExprVarNum(...)</code> and <code>mupGetVar(...)</code> with <code>mupGetExprVar(...)</code> 
in the following example. Due to the use of an temporary internal static buffer for storing the variable
name in the DLL version this DLL-function is not thread safe.

<pre>
<span class="code_cmt">// Get the number of variables</span>
<span class="code_kw">int</span> iNumVar = <span class="code_kw_lib">mupGetVarNum</span>(a_hParser);

<span class="code_cmt">// Query the variables</span>  
<span class="code_kw">for</span> (<span class="code_kw">int</span> i=<span class="code_digit">0</span>; i &lt; iNumVar; ++i)
{
  <span class="code_kw">const</span> <span class="code_kw_lib">char_type</span> *szName = <span class="code_digit">0</span>;
  <span class="code_kw">double</span> *pVar = <span class="code_digit">0</span>;
  <span class="code_kw_lib">mupGetVar</span>(a_hParser, i, &amp;szName, &amp;pVar);
  std::cout &lt;&lt; <span class="code_str">"Name: "</span> &lt;&lt; szName &lt;&lt; <span class="code_str">"   Address: [0x"</span> &lt;&lt; pVar &lt;&lt; <span class="code_str">"]\n"</span>;
}
</pre>
<small>See also: <i>example2/example2.c</i>.</small>

<h4>[Parser class interface]</h4>
For querying the expression variables exchange <code>parser.GetVar()</code> with
<code>parser.GetUsedVar()</code> in the following example.

<pre>
<span class="code_cmt">// Get the map with the variables</span>
<span class="code_kw_lib">mu::Parser::varmap_type</span> variables = <span class="code_kw_lib">parser.GetVar()</span>;
cout &lt;&lt; <span class="code_str">"Number: "</span> &lt;&lt; (<span class="code_kw">int</span>)variables.size() &lt;&lt; <span class="code_str">"\n"</span>;

<span class="code_cmt">// Get the number of variables</span> 
<span class="code_kw_lib">mu::Parser::varmap_type::</span>const_iterator item = variables.begin();

<span class="code_cmt">// Query the variables</span>
<span class="code_kw">for</span> (; item!=variables.end(); ++item)
{
  cout &lt;&lt; <span class="code_str">"Name: "</span> &lt;&lt; item->first &lt;&lt; <span class="code_str">" Address: [0x"</span> &lt;&lt; item->second &lt;&lt; <span class="code_str">"]\n"</span>;
}
</pre>

<small>
  See also: <i>example1/example1.cpp</i>.
</small>

<!-- 
//
//   The parser interface / Querying parser constants
//
-->


<h2><a id="idQueryConst"></a>Querying parser constants</h2>
Querying parser constants is similar to querying variables and expression variables. 

<h4>[DLL interface]</h4>
Due to the use of an temporary internal static buffer for storing the variable
name in the DLL version this DLL-function is not thread safe.

<pre>
<span class="code_kw">int</span> iNumVar = <span class="code_kw_lib">mupGetConstNum</span>(a_hParser);

<span class="code_kw">for</span> (<span class="code_kw">int</span> i=<span class="code_digit">0</span>; i &lt; iNumVar; ++i)
{
  <span class="code_kw">const</span> <span class="code_kw_lib">char_type</span> *szName = <span class="code_digit">0</span>;
  <span class="code_kw">double</span> fVal = <span class="code_digit">0</span>;
  <span class="code_kw_lib">mupGetConst</span>(a_hParser, i, &amp;szName, fVal);
  std::cout &lt;&lt; <span class="code_str">"  "</span> &lt;&lt; szName &lt;&lt; <span class="code_str">" = "</span> &lt;&lt; fVal &lt;&lt; <span class="code_str">"\n"</span>;
}
</pre>

<small>
  See also: <i>example2/example2.c</i>.
</small>


<h4>[Parser class interface]</h4>
The parser class provides you with the <code>GetConst()</code> member function that returns a map structure
with all defined constants. The following code snippet shows how to use it:
<pre>
<span class="code_kw_lib">mu::Parser::valmap_type</span> cmap = <span class="code_kw_lib">parser.GetConst</span>();
<span class="code_kw">if</span> (cmap.size())
{
  <span class="code_kw_lib">mu::Parser::valmap_type</span>::const_iterator item = cmap.begin();
  <span class="code_kw">for</span> (; item!=cmap.end(); ++item)
    cout &lt;&lt; <span class="code_str">"  "</span> &lt;&lt; item->first &lt;&lt; <span class="code_str">" =  "</span> &lt;&lt; item->second &lt;&lt; <span class="code_str">"\n"</span>;
}
</pre>
<small>See also: <i>example1/example1.cpp</i>.</small>

<!-- 
//
//   The parser interface / Setting custom value recognition callbacks
//
-->


<h2><a id="idDefConst2"></a>Setting custom value recognition callbacks</h2>
The parser default implementation <i>(muParser.cpp)</i> scans expressions 
only for floating point values. Custom value recognition callbacks can be used in order to 
implement support for binary, hexadecimal or octal numbers. These functions are called 
during the string parsing and allow the user to scan portions of the original expressions
for values. Their callback functions must be of the following type:

<pre>
<span class="code_kw">bool</span> (*<span class="code_kw_lib">identfun_type</span>)(<span class="code_kw">const</span> <span class="code_kw_lib">char_type</span>*, <span class="code_kw">int</span>&amp;, <span class="code_kw_lib">value_type</span>&amp;);
</pre>

<p>
If the parser reaches an a position during string parsing that could host a value token it 
tries to interpret it as such. If that fails the parser sucessively calls all 
internal value recognition callbacks in order to give them a chance to make 
sense out of what has been found. If all of them fail the parser continues to
check if it is a Variable or another kind of token. 
</p>

<p>
In order to perform the task of value recognition these functions take a <code>const char</code>
pointer, a reference to <code>int</code> and a reference 
to <code>double</code> as their arguments. 
The <code>const char</code> pointer points to the current formula position. The second
argument is the index of that position. This value must be increased by the length of the 
value entry if one has been found. In that case the value must be written to the third 
argument which is of type <code>double</code>.
</p>

<p>
The next code snippet shows a sample implementation of a function that reads and
interprets binary values from the expression string. The code is taken from 
<i>muParserInt.cpp</i> the implementation of a parser for integer numbers. Binary 
numbers must be preceded with a <code>#</code> (i.e. <code>#1000101</code>).
</p>

<pre>
<span class="code_kw">bool</span> ParserInt::IsBinVal(<span class="code_kw">const</span> <span class="code_kw_lib">char_type</span> *a_szExpr, 
                         <span class="code_kw">int</span> &amp;a_iPos, <span class="code_kw_lib">value_type</span> &amp;a_fVal)
{
  <span class="code_kw">if</span> (a_szExpr[<span class="code_digit">0</span>]!='#') 
    <span class="code_kw">return false</span>;

  <span class="code_kw">unsigned</span> iVal = <span class="code_digit">0</span>, iBits = <span class="code_kw">sizeof</span>(iVal)*<span class="code_digit">8</span>;
  <span class="code_kw">for</span> (<span class="code_kw">unsigned</span> i=<span class="code_digit">0</span>; 
       (a_szExpr[i+<span class="code_digit">1</span>]=='0'||a_szExpr[i+<span class="code_digit">1</span>]=='1')&amp;&amp; i&lt;iBits; 
       ++i)
  {
    iVal |= (<span class="code_kw">int</span>)(a_szExpr[i+<span class="code_digit">1</span>]=='1') &lt;&lt; ((iBits-<span class="code_digit">1</span>)-i);
  }

  <span class="code_kw">if</span> (i==<span class="code_digit">0</span>) 
    <span class="code_kw">return false</span>;

  <span class="code_kw">if</span> (i==iBits)
    <span class="code_kw">throw</span> <span class="code_kw_lib">exception_type</span>(<span class="code_str">"Binary to integer conversion error (overflow)."</span>);

  a_fVal = (<span class="code_kw">unsigned</span>)(iVal &gt;&gt; (iBits-i) );
  a_iPos += i+<span class="code_digit">1</span>;

  <span class="code_kw">return true</span>;
}
</pre>

Once you have the callback you must add it to the parser. This can be done with:

<h4>[DLL interface]</h4>
<pre>
<span class="code_kw_lib">mupAddValIdent</span>(hParser, IsBinVal);
</pre>

<small>
See also: <i>example2/example2.c</i>.
</small>


<h4>[Parser class interface]</h4>
<pre>
<span class="code_kw_lib">parser.AddValIdent</span>(IsBinVal);
</pre>
<small>
See also: <i>ParserLib/muParserInt.cpp</i>.
</small>

<!-- 
//
//   The parser interface / Removing variables or constants
//
-->

<h2><a id="idRemoveVar"></a>Removing variables or constants</h2>
Removing variables and constants can be done all at once using <code>ClearVar</code> and 
<code>ClearConst</code>. Additionally variables can be removed by name using 
<code>RemoveVar</code>. Since the parser never owns the variables you must take care of
their release yourself <small>(if they were dynamically allocated)</small>. If you need to browse all 
the variables have a look at the chapter explaining how to 
<a href="#idQueryVar">query parser variables</a>.


<h4>[DLL interface]</h4>
<pre>
<span class="code_cmt">// Remove all constants</span>
<span class="code_kw_lib">mupClearConst</span>(hParser);

<span class="code_cmt">// remove all variables</span>
<span class="code_kw_lib">mupClearVar</span>(hParser);

<span class="code_cmt">// remove a single variable by name</span>
<span class="code_kw_lib">mupRemoveVar</span>(hParser, <span class="code_str">"a"</span>); 
</pre>
<small>See also: example2/example2.c</small>

<h4>[Parser class interface]</h4>
<pre>
<span class="code_cmt">// Remove all constants</span>
<span class="code_kw_lib">parser.ClearConst()</span>;

<span class="code_cmt">// remove all variables</span>
<span class="code_kw_lib">parser.ClearVar()</span>;

<span class="code_cmt">// remove a single variable by name</span>
<span class="code_kw_lib">parser.RemoveVar</span>(<span class="code_str">"a"</span>);
</pre>
<small>See also: example1/example1.cpp</small>
<!-- 
//
//   The parser interface / Error handling
//
-->


<h2><a id="idErrors"></a>Error handling</h2>
In case of an error both parser class and the parser DLL provide 
similar methods for querying the information associated with the 
error. In the parser class they are member functions of the associated 
exception class <code>mu::Parser::exception_type</code> and in the DLL 
version they are normal functions.

<p>
These functions are:
</p>

<ul>
  <li><code>exception.GetMsg() / mupGetErrorMsg()</code> - returns the error message.</li>
  <li><code>exception.GetExpr() / mupGetExpr()</code> - returns the current formula (if a formula is set)</li>
  <li><code>exception.GetToken() / mupGetErrorToken()</code> - returns the token associated with the error (if applicable)</li>
  <li><code>exception.GetPos() / mupGetErrorPos()</code> - returns the current formula position (if applicable)</li>
  <li><code>exception.GetCode() / mupGetErrorCode()</code> - returns the error code.</li>
</ul>

<p>
The following table lists the parser error codes. 
The first column contains the enumeration values as defined in the enumeration <code>mu::EErrorCodes</code> 
located in the file <i>muParserError.h</i>. Since they are only accessible from C++ the second column lists 
their numeric code and the third column contains the error description.
</p>

<table border="0">
<thead>
  <tr>
    <td>             <small><b>Enumeration name</b></small></td>
    <td align="center"><small><b>Value</b></small></td>
    <td>             <small><b>Description</b></small></td>
  </tr>
</thead>

<tbody>
  <tr>
      <td><small><code>ecUNEXPECTED_OPERATOR</code></small></td>  
      <td align="center"><small>0</small></td>
      <td><small>Unexpected binary operator found</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNASSIGNABLE_TOKEN</code></small></td>
      <td align="center"><small>1</small></td>
      <td><small>Token cant be identified</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_EOF</code></small></td> 
      <td align="center"><small>2</small></td> 
      <td><small>Unexpected end of formula. (Example: "2+sin(")</small></td>
  </tr>

  <tr>
      <td><small><code>ecUNEXPECTED_ARG_SEP</code></small></td> 
      <td align="center"><small>3</small></td>  
      <td><small>An unexpected <a href="mup_locale.html#idLoc">argument separator</a> has been found. (Example: "1,23")</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_ARG</code></small></td>
      <td align="center"><small>4</small></td> 
      <td><small>An unexpected argument has been found</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_VAL</code></small></td>
      <td align="center"><small>5</small></td> 
      <td><small>An unexpected value token has been found</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_VAR</code></small></td>
      <td align="center"><small>6</small></td>  
      <td><small>An unexpected variable token has been found</small></td>
  </tr>

  <tr>
      <td><small><code>ecUNEXPECTED_PARENS</code></small></td> 
      <td align="center"><small>7</small></td>
      <td><small>Unexpected parenthesis, opening or closing</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_STR</code></small></td>
      <td align="center"><small>8</small></td> 
      <td><small>A string has been found at an inapropriate position</small></td>
  </tr>
  <tr>
      <td><small><code>ecSTRING_EXPECTED</code></small></td>
      <td align="center"><small>9</small></td>  
      <td><small>A string function has been called with a different type of argument</small></td>
  </tr>

  <tr>
      <td><small><code>ecVAL_EXPECTED</code></small></td>
      <td align="center"><small>10</small></td> 
      <td><small>A numerical function has been called with a non value type of argument</small></td>
  </tr>
  <tr>
      <td><small><code>ecMISSING_PARENS</code></small></td>
      <td align="center"><small>11</small></td> <td><small>Missing parens. (Example: "3*sin(3")</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_FUN</code></small></td>
      <td align="center"><small>12</small></td> 
      <td><small>Unexpected function found. (Example: "sin(8)cos(9)")</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNTERMINATED_STRING</code></small></td>
      <td align="center"><small>13</small></td>
      <td><small>unterminated string constant. (Example: "3*valueof("hello)")</small></td>
  </tr>
  <tr>
      <td><small><code>ecTOO_MANY_PARAMS</code></small></td>
      <td align="center"><small>14</small></td> 
      <td><small>Too many function parameters</small></td>
  </tr>
  <tr>
      <td><small><code>ecTOO_FEW_PARAMS</code></small></td> 
      <td align="center"><small>15</small></td>
      <td><small>Too few function parameters. (Example: "ite(1&lt;2,2)")</small></td>
  </tr>
  <tr>
      <td><small><code>ecOPRT_TYPE_CONFLICT</code></small></td> 
      <td align="center"><small>16</small></td> 
      <td><small>binary operators may only be applied to value items of the same type</small></td>
  </tr>
  <tr>
      <td><small><code>ecSTR_RESULT</code></small></td>  
      <td align="center"><small>17</small></td> 
      <td><small>result is a string</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_NAME</code></small></td>
      <td align="center"><small>18</small></td> 
      <td><small>Invalid function, variable or constant name.</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_BINOP_IDENT</code></small></td>
      <td align="center"><small>19</small></td> 
      <td><small>Invalid binary operator identifier.</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_INFIX_IDENT</code></small></td>
      <td align="center"><small>20</small></td> 
      <td><small>Invalid infix operator identifier.</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_POSTFIX_IDENT</code></small></td>
      <td align="center"><small>21</small></td> 
      <td><small>Invalid postfix operator identifier.</small></td>
  </tr>
  <tr>
      <td><small><code>ecBUILTIN_OVERLOAD</code></small></td>
      <td align="center"><small>22</small></td> 
      <td><small>Trying to overload builtin operator</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_FUN_PTR</code></small></td>  
      <td align="center"><small>23</small></td> 
      <td><small>Invalid callback function pointer</small></td>
  </tr>
  <tr>
      <td><small><code>ecINVALID_VAR_PTR</code></small></td>
      <td align="center"><small>24</small></td> 
      <td><small>Invalid variable pointer</small></td>
  </tr>
  <tr>
      <td><small><code>ecEMPTY_EXPRESSION </code></small></td>
      <td align="center"><small>25</small></td> 
      <td><small>The expression string is empty</small></td>
  </tr>
  <tr>
      <td><small><code>ecNAME_CONFLICT</code></small></td>  
      <td align="center"><small>26</small></td> 
      <td><small>Name conflict</small></td>
  </tr>
  <tr>
      <td><small><code>ecOPT_PRI</code></small></td>  
      <td align="center"><small>27</small></td>
      <td><small>Invalid operator priority</small></td>
  </tr>
  <tr>
      <td><small><code>ecDOMAIN_ERROR</code></small></td>
      <td align="center"><small>28</small></td>
      <td><small>catch division by zero, sqrt(-1), log(0) (currently unused)</small></td>
  </tr>
  <tr>
      <td><small><code>ecDIV_BY_ZERO</code></small></td>
      <td align="center"><small>29</small></td> 
      <td><small>Division by zero (currently unused)</small></td>
  </tr>
  <tr>
      <td><small><code>ecGENERIC</code></small></td> 
      <td align="center"><small>30</small></td> 
      <td><small>Error that does not fit any other code but is not an internal error</small></td>
  </tr>
  <tr>
      <td><small><code>ecLOCALE</code></small></td> 
      <td align="center"><small>31</small></td> 
      <td><small>Conflict with current locale</small></td>
  </tr>
  <tr>
      <td><small><code>ecUNEXPECTED_CONDITIONAL</code></small></td> 
      <td align="center"><small>32</small></td> 
      <td><small>Unexpected if then else operator</small></td>
  </tr>
  <tr>
      <td><small><code>ecMISSING_ELSE_CLAUSE</code></small></td> 
      <td align="center"><small>33</small></td> 
      <td><small>Missing else clause</small></td>
  </tr>
  <tr>
      <td><small><code>ecMISPLACED_COLON</code></small></td> 
      <td align="center"><small>34</small></td> 
      <td><small>Misplaced colon</small></td>
  </tr>
  <tr>
      <td><small><code>ecINTERNAL_ERROR</code></small></td>   
      <td align="center"><small>35</small></td> 
      <td><small>Internal error of any kind.</small></td>
  </tr>
  </tbody>
</table>

<h4>[DLL interface]</h4>
Since dynamic libraries with functions exported in C-style can't throw exceptions the DLL version
provides the user with a callback mechanism to raise errors. Simply add a callback function
that does the handling of errors. Additionally you can query the error flag with 
<code>mupError()</code>. Please note that by calling this function you will automatically reset the error flag!
<pre>
<span class="code_cmt">// Callback function for errors</span>
<span class="code_kw">void</span> OnError()
{
  cout &lt;&lt; <span class="code_str">"Message:  "</span> &lt;&lt; <span class="code_kw_lib">mupGetErrorMsg</span>() &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Token:    "</span> &lt;&lt; <span class="code_kw_lib">mupGetErrorToken</span>() &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Position: "</span> &lt;&lt; <span class="code_kw_lib">mupGetErrorPos</span>() &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Errc:     "</span> &lt;&lt; <span class="code_kw_lib">mupGetErrorCode</span>() &lt;&lt; <span class="code_str">"\n"</span>;
}

...

<span class="code_cmt">// Set a callback for error handling</span>
<span class="code_kw_lib">mupSetErrorHandler</span>(OnError);

<span class="code_cmt">// The next function could raise an error</span>
fVal = <span class="code_kw_lib">mupEval</span>(hParser);

<span class="code_cmt">// Test for the error flag</span>
<span class="code_kw">if</span> (!<span class="code_kw_lib">mupError</span>()) cout &lt;&lt; fVal &lt;&lt; <span class="code_str">"\n"</span>;
</pre>
<small>See also: example2/example2.c</small>

<h4>[Parser class interface]</h4>
In case of an error the parser class raises an exception of type <code>Parser::exception_type</code>. This 
class provides you with several member functions that allow querying the exact cause as well as 
additional information for the error.
<pre>
<span class="code_kw">try</span>
{
  ...
  <span class="code_kw_lib">parser.Eval</span>();
  ...
}
<span class="code_kw">catch</span>(<span class="code_kw_lib">mu::Parser::exception_type</span> &amp;e)
{
  cout &lt;&lt; <span class="code_str">"Message:  "</span> &lt;&lt; <span class="code_kw_lib">e.GetMsg()</span> &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Formula:  "</span> &lt;&lt; <span class="code_kw_lib">e.GetExpr()</span> &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Token:    "</span> &lt;&lt; <span class="code_kw_lib">e.GetToken()</span> &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Position: "</span> &lt;&lt; <span class="code_kw_lib">e.GetPos()</span> &lt;&lt; <span class="code_str">"\n"</span>;
  cout &lt;&lt; <span class="code_str">"Errc:     "</span> &lt;&lt; <span class="code_kw_lib">e.GetCode()</span> &lt;&lt; <span class="code_str">"\n"</span>;
}
</pre>
<small>See also: example1/example1.cpp</small>


